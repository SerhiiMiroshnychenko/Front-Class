/*
╔════════════════════════════════════════════════════════════════════════════╗
║                        SCRIPT.JS - ФАЙЛ JAVASCRIPT                         ║
║          JavaScript робить веб-сторінку ІНТЕРАКТИВНОЮ та ДИНАМІЧНОЮ        ║
╚════════════════════════════════════════════════════════════════════════════╝

JavaScript - це мова програмування, яка виконується в браузері.
Якщо HTML - скелет, CSS - одяг, то JavaScript - це МОЗОК та М'ЯЗИ сторінки.

JavaScript може:
- Реагувати на дії користувача (кліки, введення тексту)
- Змінювати вміст сторінки без перезавантаження
- Відправляти дані на сервер та отримувати відповіді
- Створювати анімації та ефекти
- Працювати з часом та таймерами
*/


// ============================================================
// СЕКЦІЯ 1: ФУНКЦІОНАЛЬНІСТЬ ГОДИННИКА
// Оновлює час на сторінці щосекунди
// ============================================================

/**
 * Функція оновлення годинника
 * 
 * Функції - це блоки коду, які виконують певну задачу.
 * Їх можна викликати (запускати) багато разів.
 * 
 * Синтаксис:
 * function назваФункції(параметри) {
 *     // код функції
 * }
 */
function updateClock() {
    // Створюємо об'єкт Date - він містить поточну дату та час
    // new Date() - повертає поточний момент часу
    const now = new Date();
    
    /*
       const - оголошення КОНСТАНТИ (незмінної змінної)
       
       Способи оголошення змінних:
       - const - константа, не можна перезаписати
       - let - змінна, можна перезаписати
       - var - старий спосіб (не рекомендується)
       
       Рекомендація: використовуйте const за замовчуванням,
       let - тільки коли значення буде змінюватись
    */
    
    // Отримуємо години, хвилини, секунди з об'єкта Date
    // .getHours(), .getMinutes(), .getSeconds() - методи об'єкта Date
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    
    /*
       Пояснення ланцюжка операцій:
       
       1. now.getHours() - повертає число (наприклад, 9)
       2. String(...) - перетворює число в текст ("9")
       3. .padStart(2, '0') - додає "0" на початок до довжини 2 ("09")
       
       Результат: "9" стає "09", "12" залишається "12"
       Це потрібно для красивого формату часу 09:05:03
    */
    
    // Знаходимо HTML елемент з id="clock" і змінюємо його текст
    // document - об'єкт, що представляє всю HTML сторінку
    // getElementById('clock') - знаходить елемент за його id
    // .textContent - властивість, що містить текст елемента
    document.getElementById('clock').textContent = `${hours}:${minutes}:${seconds}`;
    
    /*
       `${...}` - шаблонні рядки (template literals)
       Дозволяють вставляти змінні прямо в текст
       
       Еквівалент:
       hours + ':' + minutes + ':' + seconds
       
       Але шаблонні рядки зручніші та читабельніші!
    */
}


// Запускаємо годинник автоматично кожну секунду
// setInterval(функція, інтервал) - викликає функцію через заданий інтервал
// 1000 мілісекунд = 1 секунда
setInterval(updateClock, 1000);

// Викликаємо updateClock одразу, щоб не чекати першу секунду
// Інакше користувач побачить "00:00:00" протягом першої секунди
updateClock();


// ============================================================
// СЕКЦІЯ 2: ЗМІННІ ДЛЯ ЗБЕРІГАННЯ ВИТРАТ
// ============================================================

/**
 * Об'єкт для зберігання сум витрат по категоріях
 * 
 * Об'єкт - це структура даних з парами ключ: значення
 * Синтаксис: { ключ1: значення1, ключ2: значення2 }
 */
let expenseTotals = {
    products: 0,   // Витрати на продукти
    clothes: 0,    // Витрати на речі
    other: 0       // Інші витрати
};

/*
   let використано тому, що цей об'єкт буде ЗМІНЮВАТИСЬ
   (ми будемо оновлювати суми при додаванні витрат)
   
   Ці значення (0) - тимчасові, вони оновляться при 
   завантаженні даних з сервера
*/


// ============================================================
// СЕКЦІЯ 3: ФУНКЦІЯ ОНОВЛЕННЯ ВІДОБРАЖЕННЯ ВИТРАТ
// ============================================================

/**
 * Оновлює числа на екрані відповідно до даних в expenseTotals
 * 
 * Ця функція НЕ змінює дані - вона лише показує те, що в змінних
 */
function updateExpenseDisplay() {
    // Знаходимо елементи за id та оновлюємо їх текст
    // Кожен id відповідає елементу <span> в HTML
    document.getElementById('products-total').textContent = expenseTotals.products;
    document.getElementById('clothes-total').textContent = expenseTotals.clothes;
    document.getElementById('other-total').textContent = expenseTotals.other;
    
    /*
       Зверніть увагу на зв'язок:
       HTML: <span id="products-total">0</span>
       JS:   document.getElementById('products-total').textContent = 150;
       
       JavaScript знаходить елемент за id і змінює його вміст.
       Сторінка оновлюється БЕЗ перезавантаження!
    */
}


// ============================================================
// СЕКЦІЯ 4: ОТРИМАННЯ ДАНИХ З СЕРВЕРА (AJAX)
// ============================================================

/**
 * Асинхронна функція для отримання сум витрат з сервера
 * 
 * AJAX (Asynchronous JavaScript And XML) - технологія обміну
 * даними з сервером без перезавантаження сторінки
 * 
 * async/await - сучасний спосіб роботи з асинхронним кодом
 */
async function fetchExpenseTotals() {
    /*
       async перед function означає, що функція АСИНХРОННА
       
       Асинхронність - це коли код не блокує виконання.
       Поки чекаємо відповідь сервера, інший код може працювати.
       
       Аналогія: ви замовили каву і чекаєте, але можете
       перевіряти телефон поки її готують
    */
    
    try {
        /*
           try...catch - конструкція для обробки ПОМИЛОК
           
           Код в try виконується.
           Якщо сталась помилка - виконання переходить в catch.
           Без try...catch помилка "зламала" б всю програму.
        */
        
        // fetch - функція для HTTP запитів до сервера
        // await - "зачекай результат" (працює тільки в async функціях)
        const response = await fetch('http://localhost:5000/get_totals');
        
        /*
           fetch('URL') відправляє GET запит на сервер
           
           GET запит - це як "дай мені інформацію"
           URL = адреса, куди відправляємо запит
           
           http://localhost:5000 - наш локальний сервер Python
           /get_totals - маршрут (endpoint) на сервері
           
           await чекає поки сервер відповість
           response - об'єкт з відповіддю сервера
        */
        
        // Перевіряємо чи запит успішний
        // response.ok = true якщо статус 200-299 (успіх)
        if (!response.ok) {
            // throw - створює помилку та переходить в catch
            throw new Error('Не вдалось отримати суми витрат');
        }
        
        // Парсимо (розбираємо) JSON відповідь у JavaScript об'єкт
        // JSON - формат обміну даними (JavaScript Object Notation)
        const data = await response.json();
        
        /*
           Сервер повертає JSON: {"products": 150, "clothes": 200, "other": 50}
           response.json() перетворює це в JavaScript об'єкт:
           { products: 150, clothes: 200, other: 50 }
        */
        
        // Оновлюємо наш об'єкт витрат отриманими даними
        expenseTotals = data;
        
        // Оновлюємо відображення на сторінці
        updateExpenseDisplay();
        
    } catch (error) {
        // Якщо сталась помилка (сервер недоступний, проблема мережі тощо)
        // error - об'єкт з інформацією про помилку
        
        console.error('Помилка отримання сум витрат:', error);
        
        /*
           console - об'єкт для виводу в консоль браузера
           
           console.log() - звичайне повідомлення
           console.error() - повідомлення про помилку (червоним)
           console.warn() - попередження (жовтим)
           
           Консоль можна відкрити: F12 -> вкладка Console
           Це основний інструмент для відлагодження JavaScript!
        */
    }
}


// ============================================================
// СЕКЦІЯ 5: ОБРОБКА ВІДПРАВКИ ФОРМИ
// ============================================================

/**
 * Додаємо обробник події submit на форму
 * 
 * Подія (event) - це дія користувача або браузера
 * Обробник (listener) - функція, яка реагує на подію
 */
document.getElementById('expense-form').addEventListener('submit', async function(event) {
    /*
       addEventListener(тип_події, функція_обробник)
       
       'submit' - подія відправки форми (коли натискають кнопку)
       
       async function(event) - асинхронна функція-обробник
       event - об'єкт з інформацією про подію
    */
    
    // Відміняємо стандартну поведінку браузера
    // За замовчуванням форма перезавантажує сторінку - нам це не потрібно!
    event.preventDefault();
    
    /*
       preventDefault() - "відмінити стандартну дію"
       
       Для форми стандартна дія - перезавантаження сторінки.
       Ми хочемо відправити дані через AJAX без перезавантаження.
    */
    
    // Отримуємо значення з полів форми
    // .value - властивість, що містить введене користувачем значення
    const category = document.getElementById('category').value;
    const amount = parseFloat(document.getElementById('amount').value);
    
    /*
       parseFloat() - перетворює текст в число з десятковою частиною
       "150.50" -> 150.50
       
       Також є:
       parseInt() - перетворює в ціле число
       Number() - перетворює в число
    */
    
    // Перевіряємо чи дані валідні (правильні)
    if (!category || isNaN(amount) || amount <= 0) {
        // !category - категорія не вибрана (пуста)
        // isNaN(amount) - amount не є числом (NaN = Not a Number)
        // amount <= 0 - сума нульова або від'ємна
        
        // Показуємо повідомлення користувачу
        alert('Будь ласка, виберіть категорію та введіть коректну суму');
        
        /*
           alert() - показує спливаюче вікно з повідомленням
           Простий спосіб повідомити користувача, але не дуже красивий
        */
        
        // return - виходимо з функції, код нижче не виконається
        return;
    }
    
    // Якщо дані валідні - відправляємо на сервер
    try {
        // POST запит для відправки даних на сервер
        const response = await fetch('http://localhost:5000/add_expense', {
            method: 'POST',
            /*
               method: 'POST' - тип HTTP запиту
               
               Основні типи:
               - GET - отримати дані (за замовчуванням)
               - POST - відправити/створити дані
               - PUT - оновити дані
               - DELETE - видалити дані
            */
            
            headers: {
                'Content-Type': 'application/json'
            },
            /*
               headers - заголовки запиту (метадані)
               Content-Type: application/json - каже серверу,
               що ми відправляємо дані у форматі JSON
            */
            
            body: JSON.stringify({
                category: category,
                amount: amount
            })
            /*
               body - тіло запиту (самі дані)
               
               JSON.stringify() - перетворює JavaScript об'єкт в JSON рядок
               { category: 'products', amount: 150 }
               стає
               '{"category":"products","amount":150}'
               
               Це потрібно бо HTTP передає тільки текст
            */
        });
        
        // Перевіряємо успішність
        if (!response.ok) {
            throw new Error('Не вдалось додати витрату');
        }
        
        // Отримуємо оновлені суми від сервера
        const data = await response.json();
        
        // Оновлюємо локальний об'єкт та відображення
        expenseTotals = data;
        updateExpenseDisplay();
        
        // Очищуємо форму після успішного додавання
        // .reset() - скидає всі поля форми до початкових значень
        document.getElementById('expense-form').reset();
        
    } catch (error) {
        // Обробка помилок
        console.error('Помилка додавання витрати:', error);
        alert('Помилка при додаванні витрати. Спробуйте ще раз.');
    }
});


// ============================================================
// СЕКЦІЯ 6: ІНІЦІАЛІЗАЦІЯ ПРИ ЗАВАНТАЖЕННІ СТОРІНКИ
// ============================================================

/**
 * Завантажуємо початкові дані коли DOM готовий
 * 
 * DOM (Document Object Model) - це структура HTML документа
 * як дерево об'єктів, з якими працює JavaScript
 */
document.addEventListener('DOMContentLoaded', fetchExpenseTotals);

/*
   'DOMContentLoaded' - подія, яка спрацьовує коли
   HTML повністю завантажений та розібраний браузером
   
   Це гарантує, що всі елементи (id="products-total" тощо)
   вже існують коли ми намагаємося їх знайти
   
   Без цього getElementById може повернути null (нічого),
   якщо скрипт виконається раніше ніж створяться елементи
*/


/*
╔════════════════════════════════════════════════════════════════════════════╗
║                              ПІДСУМОК                                      ║
╚════════════════════════════════════════════════════════════════════════════╝

Цей JavaScript файл реалізує наступну функціональність:

1. ГОДИННИК
   - updateClock() оновлює час щосекунди
   - setInterval() запускає таймер

2. ОТРИМАННЯ ДАНИХ (при завантаженні сторінки)
   - fetchExpenseTotals() робить GET запит до сервера
   - Отримані дані зберігаються в expenseTotals
   - updateExpenseDisplay() показує їх на сторінці

3. ВІДПРАВКА ФОРМИ
   - addEventListener() слухає подію submit
   - event.preventDefault() запобігає перезавантаженню
   - Дані валідуються та відправляються POST запитом
   - Сторінка оновлюється без перезавантаження

КЛЮЧОВІ КОНЦЕПЦІЇ:
- DOM маніпуляції (getElementById, textContent)
- Події (addEventListener, submit, DOMContentLoaded)
- Асинхронність (async/await, fetch)
- JSON (stringify, parse/json())
- Обробка помилок (try...catch)

JavaScript - це "клей", який поєднує HTML інтерфейс
з Python сервером через HTTP запити!
*/
